name: ğŸš€ Deployment Pipeline

on:
  push:
    branches: [main]
    tags: ['v*.*.*']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip-tests:
        description: 'Skip pre-deployment tests'
        required: false
        default: false
        type: boolean

env:
  BUN_VERSION: 'latest'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read
  packages: write
  deployments: write
  id-token: write

concurrency:
  group: deployment-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  # Job 1: Pre-deployment validation
  pre-deployment-checks:
    name: âœ… Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: ${{ !inputs.skip-tests }}
    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: ğŸ“¦ Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: ğŸ”§ Install dependencies
        run: bun install --frozen-lockfile

      - name: ğŸ” Security pre-flight
        run: |
          npx secretlint "**/*"
          # npm audit removed
          echo "âœ… Security pre-flight checks passed"

      - name: ğŸ§ª Run unit tests
        run: |
          bun run test:unit
          bun run test:integration:frontend
          echo "âœ… Critical tests passed"

      - name: ğŸ—ï¸ Build application
        run: bun run build

      - name: ğŸ“ Check bundle size
        run: |
          bun run size-limit
          echo "âœ… Build verification passed"

      - name: ğŸ“‹ Extract version
        id: version
        run: |
          if [[ ${{ github.ref }} == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=$(bun --silent --filter . --exec "node -p \"require('./package.json').version\"")-${GITHUB_SHA::7}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deployment version: $VERSION"

  # Job 2: Build and push Docker image
  build-image:
    name: ğŸ³ Build & Push Image
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [pre-deployment-checks]
    if: always() && (needs.pre-deployment-checks.result == 'success' || needs.pre-deployment-checks.result == 'skipped')
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v6

      - name: ğŸ”§ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ”‘ Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ·ï¸ Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
          labels: |
            org.opencontainers.image.title=${{ github.repository }}
            org.opencontainers.image.description=Recipe UI Service
            org.opencontainers.image.vendor=${{ github.repository_owner }}

      - name: ğŸ—ï¸ Build and push image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_VERSION=${{ env.NODE_VERSION }}
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}

      - name: ğŸ”’ Sign container image
        uses: sigstore/cosign-installer@v3

      - name: âœï¸ Sign the published image
        run: |
          cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}

      - name: ğŸ§¾ Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: ğŸ” Scan image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: ğŸ“¤ Upload Trivy scan results
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results.sarif'

      - name: ğŸ“‹ Set image output
        id: image
        run: |
          echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

  # Job 3: Deploy to Staging
  deploy-staging:
    name: ğŸª Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [pre-deployment-checks, build-image]
    if: github.ref == 'refs/heads/main' || inputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.recipe-app.example.com

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v6

      - name: âš™ï¸ Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.STAGING_KUBECONFIG }}

      - name: ğŸ”„ Update Kubernetes manifests
        run: |
          # Update image in Kubernetes manifests
          sed -i "s|image: .*|image: ${{ needs.build-image.outputs.image }}|g" k8s/deployment.yaml
          sed -i "s|tag: .*|tag: ${{ needs.pre-deployment-checks.outputs.version }}|g" k8s/deployment.yaml

      - name: ğŸš€ Deploy to staging
        run: |
          kubectl apply -f k8s/ -n staging
          kubectl rollout status deployment/recipe-ui-service -n staging --timeout=300s
          echo "âœ… Staging deployment successful"

      - name: ğŸ¥ Health check
        run: |
          # Wait for deployment to be ready
          kubectl wait --for=condition=available deployment/recipe-ui-service -n staging --timeout=300s

          # Basic health check
          STAGING_URL="https://staging.recipe-app.example.com"
          for i in {1..5}; do
            if curl -f -s "$STAGING_URL/api/health"; then
              echo "âœ… Staging health check passed"
              break
            fi
            echo "Attempt $i failed, retrying in 30s..."
            sleep 30
          done

      - name: ğŸ§ª Post-deployment smoke tests
        run: |
          bun install --frozen-lockfile
          STAGING_URL=https://staging.recipe-app.example.com bun run test:e2e:smoke

  # Job 4: Integration Tests on Staging
  staging-integration-tests:
    name: ğŸ”— Staging Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [deploy-staging]

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v6

      - name: ğŸ“¦ Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: ğŸ”§ Install dependencies
        run: bun install --frozen-lockfile

      - name: ğŸ­ Install Playwright
        run: bun x playwright install --with-deps chromium

      - name: ğŸ§ª Run integration tests against staging
        run: |
          STAGING_URL=https://staging.recipe-app.example.com bun run test:integration:staging
        env:
          CI: true

      - name: âš¡ Performance tests on staging
        run: |
          STAGING_URL=https://staging.recipe-app.example.com bun run perf:vitals

      - name: ğŸ“¤ Upload test results
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: staging-test-results
          path: |
            test-results/
            performance-results/
          retention-days: 7

  # Job 5: Production Deployment Approval
  production-approval:
    name: ğŸ” Production Approval
    runs-on: ubuntu-latest
    timeout-minutes: 1440 # 24 hours
    needs: [staging-integration-tests]
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v') || inputs.environment == 'production'
    environment:
      name: production-approval

    steps:
      - name: â³ Awaiting approval
        run: |
          echo "ğŸ” Production deployment requires manual approval"
          echo "ğŸ“‹ Staging tests passed - ready for production"
          echo "ğŸ·ï¸ Version: ${{ needs.pre-deployment-checks.outputs.version }}"
          echo "ğŸ³ Image: ${{ needs.build-image.outputs.image }}"

  # Job 6: Deploy to Production
  deploy-production:
    name: ğŸŒŸ Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [pre-deployment-checks, build-image, production-approval]
    environment:
      name: production
      url: https://recipe-app.example.com

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v6

      - name: âš™ï¸ Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.PRODUCTION_KUBECONFIG }}

      - name: ğŸ’¾ Backup current deployment
        run: |
          kubectl get deployment recipe-ui-service -n production -o yaml > backup-deployment.yaml
          echo "âœ… Current deployment backed up"

      - name: ğŸ”„ Update Kubernetes manifests
        run: |
          sed -i "s|image: .*|image: ${{ needs.build-image.outputs.image }}|g" k8s/deployment.yaml
          sed -i "s|tag: .*|tag: ${{ needs.pre-deployment-checks.outputs.version }}|g" k8s/deployment.yaml

      - name: ğŸš€ Blue-Green Deployment
        run: |
          # Create new deployment with green label
          sed 's/app: recipe-ui-service/app: recipe-ui-service-green/g' k8s/deployment.yaml > k8s/deployment-green.yaml

          # Deploy green version
          kubectl apply -f k8s/deployment-green.yaml -n production
          kubectl rollout status deployment/recipe-ui-service-green -n production --timeout=600s

          # Health check green deployment
          kubectl wait --for=condition=available deployment/recipe-ui-service-green -n production --timeout=300s

      - name: ğŸ¥ Production health checks
        run: |
          # Get green pod IP for testing
          GREEN_POD_IP=$(kubectl get pods -l app=recipe-ui-service-green -n production -o jsonpath='{.items[0].status.podIP}')

          # Health check against green deployment
          for i in {1..10}; do
            if curl -f -s "http://$GREEN_POD_IP:3000/api/health"; then
              echo "âœ… Green deployment health check passed"
              break
            fi
            echo "Health check attempt $i failed, retrying in 10s..."
            sleep 10
          done

      - name: ğŸ”„ Switch traffic to green
        run: |
          # Update service selector to point to green deployment
          kubectl patch service recipe-ui-service -n production -p '{"spec":{"selector":{"app":"recipe-ui-service-green"}}}'
          echo "âœ… Traffic switched to green deployment"

      - name: âš¡ Check Web Vitals
        run: bun run perf:vitals

      - name: â³ Soak period
        run: |
          echo "ğŸ•°ï¸ Starting 5-minute soak period..."
          sleep 300
          echo "âœ… Soak period completed"

      - name: ğŸ§ª Production smoke tests
        run: |
          PRODUCTION_URL=https://recipe-app.example.com
          for i in {1..3}; do
            if curl -f -s "$PRODUCTION_URL/api/health"; then
              echo "âœ… Production smoke test passed"
              break
            fi
            echo "Smoke test attempt $i failed"
            sleep 30
          done

      - name: ğŸ§¹ Cleanup blue deployment
        run: |
          # Remove old blue deployment
          kubectl delete deployment recipe-ui-service -n production || true

          # Rename green to blue for next deployment
          kubectl patch deployment recipe-ui-service-green -n production -p '{"metadata":{"name":"recipe-ui-service"},"spec":{"selector":{"matchLabels":{"app":"recipe-ui-service"}},"template":{"metadata":{"labels":{"app":"recipe-ui-service"}}}}}'
          kubectl patch service recipe-ui-service -n production -p '{"spec":{"selector":{"app":"recipe-ui-service"}}}'

          echo "âœ… Deployment cleanup completed"

      - name: ğŸ“¤ Upload deployment artifacts
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: production-deployment-artifacts
          path: |
            backup-deployment.yaml
            k8s/
          retention-days: 90

  # Job 7: Post-deployment monitoring
  post-deployment-monitoring:
    name: ğŸ“Š Post-deployment Monitoring
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [deploy-production]
    if: always()

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v6

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ”§ Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: ğŸ“Š Performance monitoring
        run: |
          # Run lighthouse against production
          PRODUCTION_URL=https://recipe-app.example.com npm run perf:lighthouse
          echo "âœ… Performance monitoring completed"

      - name: ğŸ¥ Extended health monitoring
        run: |
          PRODUCTION_URL="https://recipe-app.example.com"

          echo "ğŸ” Running extended health checks..."
          for endpoint in "/api/health" "/api/recipes" "/"; do
            echo "Testing $endpoint..."
            curl -f -s "$PRODUCTION_URL$endpoint" > /dev/null
            echo "âœ… $endpoint is healthy"
          done

      - name: ğŸ“ˆ Deployment success metrics
        run: |
          echo "ğŸ“Š Deployment Metrics:"
          echo "- Version: ${{ needs.pre-deployment-checks.outputs.version }}"
          echo "- Image: ${{ needs.build-image.outputs.image }}"
          echo "- Deployment time: $(date)"
          echo "- Environment: production"
          echo "- Status: SUCCESS âœ…"

  # Rollback Job (Manual trigger)
  rollback:
    name: âª Rollback Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: failure() || cancelled()
    needs: [deploy-production]

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v6

      - name: âš™ï¸ Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.PRODUCTION_KUBECONFIG }}

      - name: âª Rollback to previous version
        run: |
          echo "ğŸš¨ Rolling back production deployment..."
          kubectl rollout undo deployment/recipe-ui-service -n production
          kubectl rollout status deployment/recipe-ui-service -n production --timeout=300s
          echo "âœ… Rollback completed"

      - name: ğŸš¨ Alert on rollback
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: |
            ğŸš¨ **PRODUCTION ROLLBACK EXECUTED** ğŸš¨
            Repository: ${{ github.repository }}
            Branch: ${{ github.ref_name }}
            Commit: ${{ github.sha }}
            Reason: Deployment failure - automatic rollback triggered
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.CRITICAL_ALERTS_SLACK_WEBHOOK_URL }}

  # Notification Job
  deployment-notification:
    name: ğŸ“¬ Deployment Notification
    runs-on: ubuntu-latest
    needs: [post-deployment-monitoring]
    if: always()

    steps:
      - name: ğŸ‰ Success notification
        if: needs.post-deployment-monitoring.result == 'success'
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            ğŸš€ **PRODUCTION DEPLOYMENT SUCCESSFUL** ğŸ‰
            Repository: ${{ github.repository }}
            Version: ${{ needs.pre-deployment-checks.outputs.version }}
            Image: ${{ needs.build-image.outputs.image }}
            URL: https://recipe-app.example.com
            All health checks passed âœ…
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: âŒ Failure notification
        if: failure() || needs.post-deployment-monitoring.result == 'failure'
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: |
            âŒ **DEPLOYMENT FAILED**
            Repository: ${{ github.repository }}
            Branch: ${{ github.ref_name }}
            Please check the workflow logs and take corrective action.
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.CRITICAL_ALERTS_SLACK_WEBHOOK_URL }}
