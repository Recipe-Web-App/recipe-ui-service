import { Meta, Canvas, Controls, Primary, Source } from '@storybook/blocks';
import { useState } from 'react';
import { ServiceErrorBoundary } from './ServiceErrorBoundary';
import {
  ServiceHealthStatus,
  ErrorSeverity,
} from '@/types/error/service-errors';

<Meta
  title="Error Handling/ServiceErrorBoundary"
  component={ServiceErrorBoundary}
  parameters={{
    layout: 'centered',
    docs: {
      description: {
        component: `
A specialized error boundary for handling microservice API errors with health monitoring, automatic retry logic, and graceful degradation.

## Features

- **Service Health Monitoring**: Track service health status (healthy, degraded, down, maintenance)
- **Network Awareness**: Detects online/offline status and provides appropriate messaging
- **Smart Retry Logic**: Automatic retry with exponential backoff for transient errors
- **HTTP Status Handling**: Context-aware error messages for common status codes (401, 403, 404, 500, 503)
- **Circuit Breaker Pattern**: Prevents cascading failures with configurable thresholds
- **Multiple Variants**: Card, inline, and banner display modes
- **Real-time Updates**: Health check polling and status indicators
- **Graceful Degradation**: Fallback UI while maintaining partial functionality

## Service Health States

- **HEALTHY**: Service is operating normally
- **DEGRADED**: Service experiencing issues but partially functional
- **DOWN**: Service is unavailable
- **MAINTENANCE**: Scheduled maintenance in progress
- **UNKNOWN**: Unable to determine service health

## Display Variants

- **card**: Full card with service status, error details, and actions
- **inline**: Compact inline message for embedding in components
- **banner**: Full-width banner for system-wide service notifications

## Usage Guidelines

- Use for wrapping API-dependent components
- Configure service name and health check endpoints
- Enable auto-retry for transient errors (503, 429, network failures)
- Set appropriate retry limits and delays
- Implement health check callbacks for monitoring
- Use circuit breaker for preventing cascading failures
        `,
      },
    },
  }}
  argTypes={{
    serviceName: {
      control: 'text',
      description: 'Name of the microservice',
    },
    variant: {
      control: 'select',
      options: ['card', 'inline', 'banner'],
      description: 'Display variant',
    },
    enableRetry: {
      control: 'boolean',
      description: 'Enable automatic retry',
    },
    checkHealth: {
      control: 'boolean',
      description: 'Enable health check polling',
    },
  }}
/>

# ServiceErrorBoundary

A microservice error boundary with health monitoring and intelligent retry.

<Primary />

<Controls />

## Display Variants

<Canvas>
  <Story name="Display Variants">
    {() => {
      const ErrorComponent = ({ statusCode }) => {
        const error = new Error('Service error occurred');
        error.statusCode = statusCode;
        error.serviceName = 'Recipe Management Service';
        throw error;
      };

      const variants = [
        { variant: 'card', label: 'Card Variant' },
        { variant: 'inline', label: 'Inline Variant' },
        { variant: 'banner', label: 'Banner Variant' },
      ];

      return (
        <div className="space-y-6 w-full max-w-2xl">
          {variants.map(({ variant, label }) => (
            <div key={variant} className="space-y-2">
              <h3 className="text-sm font-semibold text-gray-700">{label}</h3>
              <ServiceErrorBoundary
                serviceName="Recipe Management Service"
                variant={variant}
                config={{
                  serviceName: 'Recipe Management Service',
                  variant,
                  enableRetry: true,
                }}
              >
                <ErrorComponent statusCode={500} />
              </ServiceErrorBoundary>
            </div>
          ))}
        </div>
      );
    }}
  </Story>
</Canvas>

## HTTP Status Codes

<Canvas>
  <Story name="HTTP Status Codes">
    {() => {
      const statusCodes = [
        { code: 401, label: '401 - Unauthorized', description: 'Authentication required' },
        { code: 403, label: '403 - Forbidden', description: 'Access denied' },
        { code: 404, label: '404 - Not Found', description: 'Resource not found' },
        { code: 429, label: '429 - Too Many Requests', description: 'Rate limit exceeded' },
        { code: 500, label: '500 - Server Error', description: 'Internal server error' },
        { code: 503, label: '503 - Unavailable', description: 'Service unavailable' },
      ];

      const [selectedStatus, setSelectedStatus] = useState(statusCodes[0]);

      const ErrorComponent = ({ statusCode }) => {
        const error = new Error('Service request failed');
        error.statusCode = statusCode;
        error.serviceName = 'Recipe Management Service';
        throw error;
      };

      return (
        <div className="space-y-4 w-full max-w-2xl">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Select Status Code:
            </label>
            <select
              value={selectedStatus.code}
              onChange={(e) => {
                const status = statusCodes.find(s => s.code === Number(e.target.value));
                setSelectedStatus(status);
              }}
              className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              {statusCodes.map((status) => (
                <option key={status.code} value={status.code}>
                  {status.label} - {status.description}
                </option>
              ))}
            </select>
          </div>

          <ServiceErrorBoundary
            key={selectedStatus.code}
            serviceName="Recipe Management Service"
            variant="card"
            config={{
              serviceName: 'Recipe Management Service',
              enableRetry: [500, 503, 429].includes(selectedStatus.code),
              maxRetries: 3,
              retryDelay: 2000,
            }}
          >
            <ErrorComponent statusCode={selectedStatus.code} />
          </ServiceErrorBoundary>
        </div>
      );
    }}
  </Story>
</Canvas>

## Service Health States

<Canvas>
  <Story name="Service Health States">
    {() => {
      const healthStates = [
        { status: ServiceHealthStatus.HEALTHY, label: 'Healthy', description: 'Service operating normally' },
        { status: ServiceHealthStatus.DEGRADED, label: 'Degraded', description: 'Experiencing issues' },
        { status: ServiceHealthStatus.DOWN, label: 'Down', description: 'Service unavailable' },
        { status: ServiceHealthStatus.MAINTENANCE, label: 'Maintenance', description: 'Under maintenance' },
        { status: ServiceHealthStatus.UNKNOWN, label: 'Unknown', description: 'Unable to determine' },
      ];

      const ErrorComponent = ({ healthStatus }) => {
        const error = new Error('Service error');
        error.healthStatus = healthStatus;
        error.serviceName = 'Recipe Scraper Service';
        error.statusCode = healthStatus === ServiceHealthStatus.MAINTENANCE ? 503 : 500;
        throw error;
      };

      return (
        <div className="space-y-6 w-full max-w-2xl">
          {healthStates.map(({ status, label, description }) => (
            <div key={status} className="space-y-2">
              <div>
                <h3 className="text-sm font-semibold text-gray-700">{label}</h3>
                <p className="text-xs text-gray-500">{description}</p>
              </div>
              <ServiceErrorBoundary
                serviceName="Recipe Scraper Service"
                variant="card"
                config={{
                  serviceName: 'Recipe Scraper Service',
                  enableRetry: status !== ServiceHealthStatus.MAINTENANCE,
                  checkHealth: true,
                  healthCheckInterval: 30000,
                }}
              >
                <ErrorComponent healthStatus={status} />
              </ServiceErrorBoundary>
            </div>
          ))}
        </div>
      );
    }}
  </Story>
</Canvas>

## Automatic Retry

<Canvas>
  <Story name="Automatic Retry">
    {() => {
      const [attemptCount, setAttemptCount] = useState(0);

      const RetryableServiceComponent = () => {
        const currentAttempt = attemptCount;

        if (currentAttempt < 3) {
          const error = new Error('Temporary service unavailable');
          error.statusCode = 503;
          error.serviceName = 'Media Management Service';
          throw error;
        }

        return (
          <div className="p-6 bg-green-100 border border-green-300 rounded-lg">
            <div className="text-green-800">
              <div className="font-semibold text-lg mb-2">✓ Service Connected</div>
              <div className="text-sm">Successfully connected after {currentAttempt} retries</div>
            </div>
          </div>
        );
      };

      return (
        <div className="space-y-4 w-full max-w-2xl">
          <div className="p-4 bg-blue-50 rounded-lg">
            <p className="text-sm text-blue-800">
              This service will fail 3 times before succeeding. Auto-retry is enabled with exponential backoff.
            </p>
          </div>

          <ServiceErrorBoundary
            serviceName="Media Management Service"
            variant="card"
            config={{
              serviceName: 'Media Management Service',
              enableRetry: true,
              maxRetries: 5,
              retryDelay: 1000,
              exponentialBackoff: true,
            }}
            onError={() => setAttemptCount(prev => prev + 1)}
          >
            <RetryableServiceComponent />
          </ServiceErrorBoundary>

          <button
            onClick={() => setAttemptCount(0)}
            className="px-4 py-2 bg-gray-500 text-white rounded text-sm hover:bg-gray-600"
          >
            Reset Demo
          </button>
        </div>
      );
    }}
  </Story>
</Canvas>

## Network Offline Detection

<Canvas>
  <Story name="Network Offline">
    {() => {
      const [isOnline, setIsOnline] = useState(true);

      const NetworkDependentComponent = () => {
        if (!isOnline) {
          const error = new Error('Network connection lost');
          error.isNetworkError = true;
          error.serviceName = 'User Management Service';
          throw error;
        }

        return (
          <div className="p-6 bg-green-100 border border-green-300 rounded-lg">
            <div className="text-green-800">
              <div className="font-semibold text-lg mb-2">✓ Online</div>
              <div className="text-sm">Connected to User Management Service</div>
            </div>
          </div>
        );
      };

      return (
        <div className="space-y-4 w-full max-w-2xl">
          <div className="flex items-center gap-3 p-4 bg-gray-50 rounded-lg">
            <label className="flex items-center gap-2 text-sm font-medium">
              <input
                type="checkbox"
                checked={isOnline}
                onChange={(e) => setIsOnline(e.target.checked)}
                className="rounded"
              />
              Simulate Online Connection
            </label>
          </div>

          <ServiceErrorBoundary
            key={isOnline ? 'online' : 'offline'}
            serviceName="User Management Service"
            variant="card"
            config={{
              serviceName: 'User Management Service',
              enableRetry: true,
              checkHealth: true,
            }}
          >
            <NetworkDependentComponent />
          </ServiceErrorBoundary>
        </div>
      );
    }}
  </Story>
</Canvas>

## Multiple Services

<Canvas>
  <Story name="Multiple Services">
    {() => {
      const services = [
        { name: 'Auth Service', status: 'healthy', port: 8081 },
        { name: 'Recipe Management', status: 'error', port: 8082 },
        { name: 'Recipe Scraper', status: 'healthy', port: 8083 },
        { name: 'Media Management', status: 'maintenance', port: 8084 },
        { name: 'User Management', status: 'error', port: 8085 },
        { name: 'Meal Plan Management', status: 'healthy', port: 8086 },
      ];

      const ServiceComponent = ({ serviceName, status }) => {
        if (status === 'error') {
          const error = new Error('Service request failed');
          error.statusCode = 500;
          error.serviceName = serviceName;
          throw error;
        }

        if (status === 'maintenance') {
          const error = new Error('Service under maintenance');
          error.statusCode = 503;
          error.serviceName = serviceName;
          error.healthStatus = ServiceHealthStatus.MAINTENANCE;
          throw error;
        }

        return (
          <div className="p-3 bg-green-50 border border-green-200 rounded text-sm text-green-700">
            ✓ Connected
          </div>
        );
      };

      return (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-4xl">
          {services.map((service) => (
            <div key={service.name} className="space-y-2">
              <div className="flex items-center justify-between">
                <h3 className="text-sm font-semibold text-gray-700">{service.name}</h3>
                <span className="text-xs text-gray-500">:{service.port}</span>
              </div>
              <ServiceErrorBoundary
                serviceName={service.name}
                variant="inline"
                config={{
                  serviceName: service.name,
                  enableRetry: service.status === 'error',
                  maxRetries: 2,
                }}
              >
                <ServiceComponent serviceName={service.name} status={service.status} />
              </ServiceErrorBoundary>
            </div>
          ))}
        </div>
      );
    }}
  </Story>
</Canvas>

## Circuit Breaker

<Canvas>
  <Story name="Circuit Breaker">
    {() => {
      const [failureCount, setFailureCount] = useState(0);
      const [circuitOpen, setCircuitOpen] = useState(false);

      const CircuitBreakerComponent = () => {
        if (circuitOpen) {
          const error = new Error('Circuit breaker is open - too many failures detected');
          error.statusCode = 503;
          error.serviceName = 'Recipe Management Service';
          error.circuitOpen = true;
          throw error;
        }

        if (failureCount < 5) {
          const error = new Error('Service temporarily unavailable');
          error.statusCode = 503;
          error.serviceName = 'Recipe Management Service';
          throw error;
        }

        return (
          <div className="p-6 bg-green-100 border border-green-300 rounded-lg">
            <div className="text-green-800">
              <div className="font-semibold text-lg mb-2">✓ Service Recovered</div>
              <div className="text-sm">Circuit breaker closed, service operational</div>
            </div>
          </div>
        );
      };

      const handleError = () => {
        const newCount = failureCount + 1;
        setFailureCount(newCount);

        if (newCount >= 5) {
          setCircuitOpen(true);
          // Simulate circuit breaker opening for 10 seconds
          setTimeout(() => {
            setCircuitOpen(false);
            setFailureCount(0);
          }, 10000);
        }
      };

      return (
        <div className="space-y-4 w-full max-w-2xl">
          <div className="p-4 bg-amber-50 rounded-lg">
            <p className="text-sm text-amber-800 mb-2">
              After 5 consecutive failures, the circuit breaker will open and prevent further requests for 10 seconds.
            </p>
            <div className="text-xs text-amber-700">
              Failures: {failureCount}/5 | Circuit: {circuitOpen ? 'OPEN' : 'CLOSED'}
            </div>
          </div>

          <ServiceErrorBoundary
            key={`${failureCount}-${circuitOpen}`}
            serviceName="Recipe Management Service"
            variant="card"
            config={{
              serviceName: 'Recipe Management Service',
              enableRetry: !circuitOpen,
              maxRetries: 3,
              circuitBreakerThreshold: 5,
              circuitBreakerTimeout: 10000,
            }}
            onError={handleError}
          >
            <CircuitBreakerComponent />
          </ServiceErrorBoundary>

          <button
            onClick={() => {
              setFailureCount(0);
              setCircuitOpen(false);
            }}
            className="px-4 py-2 bg-gray-500 text-white rounded text-sm hover:bg-gray-600"
          >
            Reset Circuit Breaker
          </button>
        </div>
      );
    }}
  </Story>
</Canvas>

## Best Practices

### Do&apos;s
- ✅ Use service error boundaries for API-dependent components
- ✅ Configure service name for better error context
- ✅ Enable retry for transient errors (503, 429, network failures)
- ✅ Implement health check polling for critical services
- ✅ Use circuit breaker to prevent cascading failures
- ✅ Provide fallback UI or cached data when possible
- ✅ Track service errors in monitoring/analytics

### Don&apos;ts
- ❌ Don&apos;t enable auto-retry for authentication errors (401, 403)
- ❌ Don&apos;t set retry limits too high (max 3-5 attempts)
- ❌ Don&apos;t retry on 4xx errors (except 429)
- ❌ Don&apos;t ignore circuit breaker open state
- ❌ Don&apos;t forget to configure health check endpoints
- ❌ Don&apos;t use the same retry strategy for all services

### When to Use Each Variant

**card**: Full component replacement, prominent error display, standalone widgets
**inline**: Form fields, list items, embedded components, compact spaces
**banner**: System-wide notifications, critical service outages, maintenance alerts

### Retry Strategy by Status Code

**Retry with backoff**: 503 (Service Unavailable), 429 (Rate Limited), 502/504 (Gateway errors)
**Do not retry**: 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found)
**Limited retry**: 500 (Internal Server Error) - max 2-3 attempts

<Source
  language="tsx"
  code={`
// Basic usage
<ServiceErrorBoundary
  serviceName="Recipe Management Service"
  variant="card"
>
  <RecipeList />
</ServiceErrorBoundary>

// With retry configuration
<ServiceErrorBoundary
  serviceName="Recipe Scraper Service"
  variant="card"
  config={{
    serviceName: 'Recipe Scraper Service',
    enableRetry: true,
    maxRetries: 3,
    retryDelay: 2000,
    exponentialBackoff: true,
  }}
>
  <ScrapedRecipes />
</ServiceErrorBoundary>

// With health monitoring
<ServiceErrorBoundary
  serviceName="Media Management Service"
  variant="inline"
  config={{
    serviceName: 'Media Management Service',
    checkHealth: true,
    healthCheckInterval: 30000,
    healthCheckUrl: '/api/v1/media/health',
  }}
  onHealthChange={(status) => {
    console.log('Service health:', status);
  }}
>
  <MediaUploader />
</ServiceErrorBoundary>

// With circuit breaker
<ServiceErrorBoundary
  serviceName="User Management Service"
  variant="card"
  config={{
    serviceName: 'User Management Service',
    enableRetry: true,
    circuitBreakerThreshold: 5,
    circuitBreakerTimeout: 60000,
  }}
  onError={(error, metadata) => {
    trackServiceError(error, metadata);
  }}
>
  <UserProfile />
</ServiceErrorBoundary>
`}
/>
